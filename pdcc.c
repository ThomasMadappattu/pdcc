#include "io.h"
#include "codegen.h"
#include "lex.h"
#include "parser.h"
#include "error.h"
#include "symtab.h"
#include <string.h>
#define getch() ;

/*
***********************************************************************************
happy path test case for the code generator
***********************************************************************************
*/
void test_codegen_happy_path(void)
{
    init_codegen("testc.asm");
    write_comment("========================================");
    write_comment(" This is generated by the PDCC compiler ");
    write_comment("=======================================") ;
    write_comment("Exit to DOS ") ;
    write_line("mov ax , 4c00h");
    write_line("int 21h");
    shut_codegen();
}

/*
***********************************************************************************
happy  path testing for the io module
***********************************************************************************
*/
void test_io_happy_path(void)
{
   int k = 0 ;
   FILE_T test_file ;
   init_file(&test_file,"test1.c");

   open_file(&test_file) ;
   printf("File length = %d" ,file_length(test_file));
   getch();
   for ( k = 0 ; k < file_length(test_file) ; k++)
   {
     printf ("%c" , get_char_from_file(&test_file,k)) ;
   }
   getch();
   close_file(&test_file);
}

/*
***********************************************************************************
happy path testing of the lex module
***********************************************************************************
*/

void test_lex_happy_path(void)
{

   char token[TOKEN_MAX];
   init_lex("dummy.c");
   while ( !end_of_file())
   {
      skip_blanks() ;
      if ( match("int") )
      {
        printf("\n matched int \n");
      }
      advance_lex(strlen("int"));
      skip_blanks();
      if ( match ( "a") )
      {
         printf("\n matched a \n");
      }
      advance_lex(1);
      skip_blanks();
      if ( match ( ",") )
      {
         printf("\n matched  , " ) ;
      }
      advance_lex(1);
      skip_blanks();
      if ( match( "b"))
      {
          printf( "\n matched b ") ;
       }
       advance_lex(1);
       skip_blanks();
       if ( match (";"))
       {
          printf ("\n matched ;");
       }
       advance_lex(1);
       skip_blanks();
       if ( match( "foobar"))
       {
          printf ("\n matched foobar ") ;
       }
       skip_blanks();
   }
   close_lex();
   init_lex("dummy.c");
   while(!end_of_file())
   {
      skip_blanks();
      get_token_space(token);
      printf("\n%s",token);
   }
   close_lex();
}
/*
***********************************************************************************
happy path testing of the lexical analyzer module
***********************************************************************************
*/
void test_lex_happy_path2(void)
{
  TOKEN_T token;
  TOKEN_VALUE_T val;
  init_lex("test1.c");
  while(!end_of_file())
  {
     init_token(&token);
     get_token(&token,&val);
     printf("\n Token Type = %d" , token.type);
     printf("\n Token  = %s" , token.token);
     getch() ;
  }
  close_lex();
}

/*
***********************************************************************************

 happy path testing of the parser module
***********************************************************************************
*/
void test_parser_happy_path(void)
{
    parse_unit("test.txt");

}

/*
*******************************************************************************
happy path testing of the generic linked list module
*******************************************************************************
*/
void test_linked_list_happy_path(void)
{
    LIST_T  list ;
    init_list(&list);
    insert_head(&list,"ping");
    insert_head(&list,"2");
    insert_tail(&list,"dong");
    insert_tail(&list,"song");
    delete_tail(&list);
    delete_head(&list);
    print_list(list);
}



/*
 * ****************************************************************************************
 * happy path testing for parse declaration function
 * ****************************************************************************************
 */
void test_parse_declaration(void)
{


    char  *filename="testdecl.txt";
    char  *filename_ptr = filename;
    char* output_file= malloc ( sizeof(filename) + 5 );
    TOKEN_T current_token;
    TOKEN_VALUE_T token_value;

    init_token(&current_token);
    init_lex(filename);
    strcpy(output_file,filename);
    setup_sym_tables();
    filename_ptr = output_file;

    while( *filename_ptr != '\0' && *filename_ptr !='.')
    {
       ++filename_ptr;
    }

    ++filename_ptr;
    *filename_ptr = '\0';
    strcpy(filename_ptr,"asm");
    strcat(filename_ptr,"\0");
    printf("Output File = %s " , output_file);
    init_codegen(output_file);
    while(!end_of_file())
    {
        skip_blanks();
        skip_comments();
        get_token(&current_token, &token_value);
        parse_declaration(&current_token, &token_value, TRUE);
	printf("\n ** Current Token  = %s " , current_token.token);
    }
    close_lex();
    shut_codegen();
    dump_globals();
}

/*
 *****************************************************************************************

  happy path testing for the parse experssion function
 *****************************************************************************************

 */
void test_parse_expression(void)
{


}

int main()
{
    /*
     Write PDCC compiler
    */
    test_io_happy_path();
    test_codegen_happy_path();
    test_lex_happy_path();
    test_parser_happy_path();
    test_linked_list_happy_path();
    test_parse_declaration();
    return EXIT_SUCCESS;

}
